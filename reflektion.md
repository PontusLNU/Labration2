# Reflektion

### Namngivning Kapitel 2

| Namn| Förklaring | Regler från clean code | Reflektion |
|---|---|---|---|
| **convertKgToLbs()** | En metod som omvandlar en vikt i kg till pounds | **1.Use Intention-Revealing Names** **2.Avoid Disinformation** | **1.** Tydligt tycker jag vad denna metod ska göra sett till namngivningen. Denna ligger även i en klass som heter WeightConverter vilket gör att lägga till weight i namnet på metoden skulle vara överflödigt och kladdigt.  **2.** Kan inte påstå att det finns något missvisande i denna namngivning. Den håller sig till vad metoden gör. |  
| **validateInput()** | En metod som validerar att argumentet till en metod är av rätt typ | **1.Pick One Word per Concept**, **2.Don’t Be Cute**  | **1.** Här har jag gått ifrån detta lite, i de flesta fall så används just denna metod och namn men i klassen TimeConverter så har jag istället valt att namnge det handle12HourInput när jag här också validerar indatan. Jag kommer dock behålla det så och anledningen till denna namngivning är att jag inte bara validerar indatan utan även manipulerar den.  **2.** Klart och tydligt vad denna metod gör genom namngivningen. Det finns inte någon tillstymmelse till humor i denna eller någon av mina namngivningar. |
| **TimeConverter** | En klass som innehåller metoder som omvandlar tid mellan 12h och 24h format| **1.Class Names**, **2.Don’t Add Gratuitous Context**| **1.** Klass namnet är ett substantiv, vilket är korrekt enligt vad som skrivs i boken om "Class names", metoder däremot ska skrivas som verb.  **2.** Onödigt prefixar eller klutter? Nej skulle jag säga. Converter förekommer i såväl modulnamn, klassnamn och i metoder men enligt mig så är det bra namngivning. Hade klassen endast hetat Time så hade det inte varit tydligt vad den gör. Möjligtvis hade det kanske varit det ändå, med tanke på att alla klasser konverterar något. Men i min mening är namngivningen som den är nu bra. |
| **formattedTime** | En variabel som formatterar argumentet till en sträng i det formatet som behövs för att omvandla tiden | **1.Avoid Mental Mapping** **2.Use Searchable Names** | **1.** Enkelt att förstå, läsaren behöver inte fundera på vad som menas med variabelnamnet då det klart och tydligt säger vad det är frågan om.  **2.** Beskrivande namn som är lätt att hitta i kodbasen står det i boken och det tycker jag också stämmer väl in på denna. |
| **period** |En variabel som får strängen 'AM' eller 'PM' beroende på vilken tid som angets i 12h format | **1.Use Pronounceable Names**, **2.Add Meaningful Context** | **1.** Inga konstigheter här då variabelnamnet är ett vanligt ord och blir således lätt att uttala  **2.** Ordet period i sig är inte så självklart på vad det menar men det blir ändå i kontexten tydligt vad som menas när den förekommer så att tiden i hh:mm(AM/PM) delas upp i tre variabler: hours12, minutes och period. |

### Reflektion Kapitel 2
Jag tycker jag följer reglerna i kapitel 2 bra. Det beror främst på att vi jobbat med detta genom hela utbildningen egentligen, men inte i den utsträckningen denna kurs innefattar. Samt att eftersom detta är en kurs i kodkvalitét så är man ju extra eftertänksam när man namnger sina klasser, metoder och variabler. Kanske är det så att just variablerna är det som är svårare att få till eftersom dom skapas mer "on the run" och om man inte stannar till och tänker efter så kan det lätt bli att just variabelnamnen kan bli sämre. Jag vet att jag under arbetets gång har ändrat variabelnamn för att det ska bli bra namngivning. Och även i mina testfiler så ändrade jag namn från t.ex. const tc = new TemperatureConverter till const temperatureConverter, med kurslitteratur och föreläsningar i bakhuvudet.

### Funktioner Kapitel 3

| Metodnamn | Antal rader | Regler | Reflektion |
|---|---|---|---|
| **handle12HourInput()** | 23 | **1.Small**, **2.Do One Thing** | **1.** Metoden är kanske inte jättestor men den är störst i sammanhanget och bryter mot regeln "Small"  **2.** Metoden är tänk att egentligen att göra en sak men den gör mer än så. Den ska validera indatan. Men utöver detta så manipulerar den också indatan och returnerar ett objekt av manipulierad data av argumentet. Men det går att argumentera för att den trots allt bara gör en sak vilket är att validera indatan och kasta ett error om den inte är giltig då den endast returnerar giltiga argument. |
| **handle24HourInput()** | 18 | **1.Small**, **2.Do One Thing** **3.Function Aarguments** | **1. & 2.** Min näst största metod, den gör egentligen samma sak som föregående med undantaget att den inte behöver hantera AM/PM och blir således lite mindre. Validerar datan och manipulerar den innan den returnerar ett objekt av detta. Kan nog förbättras genom att ha mer gemensamt med handle12HourInput() och bryta ut viss funktionalitet som att hantera AM/PM till en separat metod. **3.** Metoden är monadic då den endast tar ett argument.  |
| **convert12HourTo24Hour()** | 18 | **1.Do one thing**, **2.Have No Side Effects** | **1.** Metoden gör en sak, den konverterar 12h tid till 24h tid.  **2.**  Metoden har inga sidoeffekter den fokuserar på en sak vilket är omvandlingen av tiden. |
| **convert24HourTo12Hour()** | 6 | **1.Single Level of Abstraction** **2.Don't Repeat Yourself** | **1.**Genom att använda sig av en annan metod för att validera indatan så håller den sig till en nivå av abstraktion.  **2.**Metoden gör det den ska utan att upprepa sig |
| **validateInput()** | 3 | **Small**, **Do one thing**, **Function Aarguments** | Metoden är liten, den gör bara en sak vilket är att validera indatan och den tar endast ett argument och är således monadic. |

### Reflektion Kapitel 3
Jag förstår vad man vill åstadkomma med att göra korta funktioner från kapitlet i boken och att det är fördelaktigt framförallt om man läser eller arbetar i någon annans kod. För att reflektera till min egen kod i detta projekt så har jag "tyvärr" inte så långa funktioner. Hade jag gjort en annan typ av modul så hade jag kanske åkt på mer tankeställare och fått klura mer. Men jag har haft kapitlet i åtanke och försökt bryta ut kod där det varit möjligt och det går med all säkehet att göra ännu bättre. Denna modul består av många väldigt enkla och korta metoder vilket gör att det har löst sig själv, men jag kan definitivt se mönster i tidigare projekt där det går att göra många förbättringar genom att eftersträva korta "Do one thing" -funktioner till exempel.

## Avslutande reflektion.
Kodkvalitéten i denna modul sett till de regler jag gått igenom ovan är bra. Metoderna är korta, gör en sak och har inga sidoeffekter. Jag har även lyckats undvika att repetera mig själv genom att skapa metoder för att validera argumenten istället för att göra det i varje metod. Däremot har majoriteten av metoderna inte varit särskilt komplexa , vilket jag märkte under arbetets gång med modulen. Det var svårt att välja vad jag skulle göra för modul och hur stor och komplex den skulle bli på förhand innan man kommit en bit på den. Namngivningen är jag också nöjd med men det var också något jag hade med mig in i uppgiften från föreläsningen, kurslitteraturen samt att vi fått det i tidigare kurser. Namnen på klasser, metoder och variabler är tydliga och sökbara och ger meningsfull kontext. Jag har också försökt hålla mig till “Pick one word per concept” men har fått avvika lite från den i mina metoder för att hantera argumenten beroende på om jag bara validerat datan eller om jag också har gjort något med den på vägen. Metoderna håller sig också till en och samma abstraktionsnivå. Om jag zoomar ut lite så kan jag se att jag har mycket att ta till mig från boken avseende kodkvalitet och något jag tyckte var intressant var att om man behöver kommentera något i en funktion så kan man förmodligen bryta ut det till en egen separat funktion. Som tidigare nämnt också så kan jag tycka att det är svårare med variabelnamn då dom oftast kommer i ett flow av skrivande medan namn på metoder och framförallt klasser skrivs med mer eftertänksamhet. Jag har själv varit med om att gå tillbaka och kolla på kod som man skrivit tidigare i utbildningen där man fått bläddra mellan metoder och klasser för att förstå vad det var man menade där och då. Därav ligger vikten också att skriva bra kod från början för att slippa gå tillbaka och ändra.
